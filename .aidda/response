File: /home/stevegt/lab/markproc/README.md
```markdown
# Markdown Preprocessor

This project provides a Go-based preprocessor for Markdown files that
creates anchors and links for references and headings. The tool is a
command-line utility that reads a Markdown file from standard input
and writes the processed content to standard output.

## Features

- Creates anchor links for lines starting with `[REF]:`
- Converts `[REF]` references to links and validates them
- Tracks other references and attempts to link them to headings using fuzzy matching
- Prints warnings for references that cannot be conclusively matched

## Usage

To use the preprocessor, run it as a command in your terminal:

```bash
go run main.go < your_markdown_file.md > processed_markdown.md
```

Here, `your_markdown_file.md` is the Markdown file you want to process, and `processed_markdown.md` is the output file with processed content.

### Example

#### Input

```markdown
# A Top-Level Heading

This is the first section.

## A Section Heading

This is a reference to the Section One heading [sec top].

Reference to the anchor below [ref1].

## References

[ref1]: A bibliographic reference.
```

#### Output

```markdown
<a name="sec1"></a>
# 1. A Top-Level Heading

This is the first section.

<a name="sec1_1"></a>
## 1.1 A Section Heading

This is a reference to the Section One heading [<a href="#sec1">sec 1</a>].

Reference to the anchor below [<a href="#ref1">ref1</a>].

## References

<a name="ref1"></a>
[ref1]: A bibliographic reference.
```

In this example:

- Internal section references use section numbers, allowing them to be easily distinguished from external references.
- Each section heading gets a unique numeric section identifier and an associated anchor.

### Testing

Test cases have been added for each processing pass function to ensure the correct transformation of markdown content.

```
EOF_/home/stevegt/lab/markproc/README.md

File: /home/stevegt/lab/markproc/main.go
```go
package main

import (
	"bufio"
	"crypto/sha256"
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/stevegt/fuzzy"
)

type Reference struct {
	Name     string
	Line     int
	Resolved bool
}

type Target struct {
	Name         string
	Heading      string
	Number       string
	HeadingLower string
}

type References []Reference
type Targets []Target

var (
	refRegexp     = regexp.MustCompile(`\[(\w+)\][^:]`)
	extLinkRegexp = regexp.MustCompile(`^\[(\w+)\]:\s+`)
	headerRegexp  = regexp.MustCompile(`^(#+)\s+(.+)`)
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	writer := bufio.NewWriter(os.Stdout)
	defer writer.Flush()

	lines := []string{}
	for scanner.Scan() {
		line := scanner.Text()
		lines = append(lines, line)
	}

	if err := scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "Error reading stdin: %v\n", err)
		os.Exit(1)
	}

	lines = passFindRefs(lines)
	lines = passMkExterns(lines)
	lines = passMkHeads(lines)
	lines = passLinkExterns(lines)
	lines = passLinkHeads(lines)

	for _, line := range lines {
		writer.WriteString(line + "\n")
	}
	writer.Flush()
}

func generateSectionNumber(level int, index int, parentNumber string) string {
	if parentNumber == "" {
		return fmt.Sprintf("%d", index+1)
	}
	return fmt.Sprintf("%s.%d", parentNumber, index+1)
}

func passFindRefs(lines []string) []string {
	newLines := []string{}
	for _, line := range lines {
		if refMatch := refRegexp.FindAllStringSubmatch(line, -1); len(refMatch) > 0 {
			for _, match := range refMatch {
				ref := match[1]
				line = strings.Replace(line, fmt.Sprintf("[%s]", ref), fmt.Sprintf("[%s](#%s)", ref, ref), -1)
			}
		}
		newLines = append(newLines, line)
	}
	return newLines
}

func passMkExterns(lines []string) []string {
	newLines := []string{}
	targets := Targets{}
	for _, line := range lines {
		if extMatch := extLinkRegexp.FindStringSubmatch(line); len(extMatch) > 0 {
			ref := extMatch[1]
			targets = append(targets, Target{Name: ref, Heading: line, HeadingLower: strings.ToLower(line)})
			line = fmt.Sprintf(`<a name="%s"></a>`, ref) + line
		}
		newLines = append(newLines, line)
	}
	return newLines
}

func passMkHeads(lines []string) []string {
	hash := sha256.New()
	for _, line := range lines {
		hash.Write([]byte(line))
	}

	newLines := []string{}
	sectionNumbers := []int{0, 0, 0, 0, 0} // Support for up to 5 levels of headings
	targets := Targets{}
	for _, line := range lines {
		if headerMatch := headerRegexp.FindStringSubmatch(line); len(headerMatch) > 0 {
			level := len(headerMatch[1])
			sectionNumbers[level-1]++
			for i := level; i < 5; i++ {
				sectionNumbers[i] = 0
			}
			var parentNumber string
			if level > 1 {
				parentNumber = fmt.Sprintf("%d", sectionNumbers[level-2])
			}
			sectionNumber := generateSectionNumber(level, sectionNumbers[level-1]-1, parentNumber)
			headerName := headerMatch[2]
			headerLink := fmt.Sprintf("sec%s", strings.Replace(sectionNumber, ".", "_", -1))
			targets = append(targets, Target{Name: headerLink, Heading: headerName, HeadingLower: strings.ToLower(headerName), Number: sectionNumber})

			line = fmt.Sprintf(`<a name="%s"></a>%s %s. %s`, headerLink, headerMatch[1], sectionNumber, headerName)
		}
		newLines = append(newLines, line)
	}
	return newLines
}

func passLinkExterns(lines []string) []string {
	references := References{}
	targets := Targets{}
	for i, ref := range references {
		for _, target := range targets {
			if ref.Name == target.Name {
				references[i].Resolved = true
				break
			}
		}
	}
	return lines
}

func passLinkHeads(lines []string) []string {
	newLines := []string{}
	references := References{}
	targets := Targets{}
	loweredTargets := map[string]string{}
	for _, target := range targets {
		loweredTargets[target.HeadingLower] = target.Name
	}

	for i, ref := range references {
		if ref.Resolved {
			continue
		}
		matches := fuzzy.Match(strings.ToLower(ref.Name), keys(loweredTargets))
		insertionOnly := []string{}
		for _, match := range matches {
			if match.Insertions > 0 && match.Substitutions == 0 && match.Deletions == 0 {
				insertionOnly = append(insertionOnly, match.Original)
			}
		}
		switch len(insertionOnly) {
		case 0:
			fmt.Fprintf(os.Stderr, "Warning: No matches for unresolved reference [%s]\n", ref.Name)
			newLines = append(newLines, lines[ref.Line])
		case 1:
			resolvedName := loweredTargets[insertionOnly[0]]
			// find the target
			var target Target
			for _, t := range targets {
				if t.Name == resolvedName {
					target = t
					break
				}
			}

			// rewrite the reference in newLines
			line := lines[ref.Line]
			linkContent := fmt.Sprintf("sec %s", target.Number)
			link := fmt.Sprintf("[%s](#%s)", linkContent, resolvedName)
			refStr := fmt.Sprintf("[%s]", link)
			line = strings.Replace(line, fmt.Sprintf("[%s]", ref.Name), refStr, -1)
			ref.Name = resolvedName
			newLines = append(newLines, line)

			// Mark ref as resolved
			references[i].Resolved = true
		default:
			fmt.Fprintf(os.Stderr, "Warning: Multiple matches for unresolved reference [%s]\n", ref.Name)
			newLines = append(newLines, lines[ref.Line])
		}
	}

	return newLines
}

func keys(m map[string]string) []string {
	s := make([]string, 0, len(m))
	for key := range m {
		s = append(s, key)
	}
	return s
}
```
EOF_/home/stevegt/lab/markproc/main.go

File: /home/stevegt/lab/markproc/main_test.go
```go
package main

import (
	"bytes"
	"os/exec"
	"reflect"
	"strings"
	"testing"
)

func TestMarkdownPreprocessor(t *testing.T) {
	input := `# A Top-Level Header

This is the first section.

## A Sub-Level Header

This is a reference to the Section One heading [sec top].

Reference to the anchor below [ref1].

## References

[ref1]: A bibliographic reference.`

	expectedOutput := `<a name="sec1"></a>
# 1. A Top-Level Header

This is the first section.

<a name="sec1_1"></a>
## 1.1 A Sub-Level Header

This is a reference to the Section One heading [<a href="#sec1">sec 1</a>].

Reference to the anchor below [<a href="#ref1">ref1</a>].

## References

<a name="ref1"></a>
[ref1]: A bibliographic reference.`

	cmd := exec.Command("go", "run", "main.go")
	cmd.Stdin = bytes.NewReader([]byte(input))

	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("cmd.Run() failed with %s\n", err)
	}

	actualOutput := string(output)
	if actualOutput != expectedOutput {
		t.Errorf("Expected:\n%s\nGot:\n%s\n", expectedOutput, actualOutput)
	}
}

func TestPassFindRefs(t *testing.T) {
	lines := []string{
		"This is a [reference] to something.",
		"No refs here.",
	}
	expectedLines := []string{
		"This is a [reference](#reference) to something.",
		"No refs here.",
	}

	result := passFindRefs(lines)
	if !reflect.DeepEqual(result, expectedLines) {
		t.Errorf("passFindRefs failed:\nexpected: %v\ngot: %v", expectedLines, result)
	}
}

func TestPassMkExterns(t *testing.T) {
	lines := []string{
		"[ref1]: A bibliographic reference.",
		"No externs here.",
	}
	expectedLines := []string{
		`<a name="ref1"></a>[ref1]: A bibliographic reference.`,
		"No externs here.",
	}

	result := passMkExterns(lines)
	if !reflect.DeepEqual(result, expectedLines) {
		t.Errorf("passMkExterns failed:\nexpected: %v\ngot: %v", expectedLines, result)
	}
}

func TestPassMkHeads(t *testing.T) {
	lines := []string{
		"# Top-Level Header",
		"This is a paragraph.",
		"## Sub-Level Header",
	}
	expectedLines := []string{
		`<a name="sec1"></a># 1. Top-Level Header`,
		"This is a paragraph.",
		`<a name="sec1_1"></a>## 1.1 Sub-Level Header`,
	}

	result := passMkHeads(lines)
	if !reflect.DeepEqual(result, expectedLines) {
		t.Errorf("passMkHeads failed:\nexpected: %v\ngot: %v", expectedLines, result)
	}
}

func TestPassLinkExterns(t *testing.T) {
	lines := []string{
		"This is a reference to [ref1].",
		"No external links here.",
	}

	// Initialize references and targets globally, adjusting their values for the test scenario
	references = References{
		{Name: "ref1", Line: 0, Resolved: false},
	}
	targets = Targets{
		{Name: "ref1", Heading: "Reference", Number: "1"},
	}

	result := passLinkExterns(lines)
	expectedLines := []string{
		"This is a reference to [<a href=\"#ref1\">ref1</a>].",
		"No external links here.",
	}

	if !reflect.DeepEqual(result, expectedLines) {
		t.Errorf("passLinkExterns failed:\nexpected: %v\ngot: %v", expectedLines, result)
	}
}

func TestPassLinkHeads(t *testing.T) {
	lines := []string{
		"This is a reference to [sec top].",
		"No header links here.",
	}
	
	references = []Reference{
		{Name: "sec top", Line: 0, Resolved: false},
	}
	targets = []Target{
		{Name: "sec1", Heading: "Top-Level Header", Number: "1", HeadingLower: "top-level header"},
	}

	result := passLinkHeads(lines)
	expectedLines := []string{
		"This is a reference to [<a href=\"#sec1\">sec 1</a>].",
		"No header links here.",
	}

	if !reflect.DeepEqual(result, expectedLines) {
		t.Errorf("passLinkHeads failed:\nexpected: %v\ngot: %v", expectedLines, result)
	}
}
```
EOF_/home/stevegt/lab/markproc/main_test.go